======
for statement
======

for x in y {}
for x: Int in y {}

---

(program
  (for_in_statement
    variable: (identifier_pattern
      (identifier))
    collection: (expression
      postfix_expression: (identifier)))
  (for_in_statement
    variable: (identifier_pattern
      (identifier))
    variable: (type_annotation
      (type_identifier
        identifier: (identifier)))
    collection: (expression
      postfix_expression: (identifier))))

======
while statement
======

while #available(iOS 13.0, *) {}
while let x = y, z = y {}

---

(program
	(while_statement (availability_condition))
	(while_statement (optional_binding_condition (optional_binding (identifier) (identifier)) (optional_binding (identifier) (identifier)))))

======
repeat while statement
======

repeat {} while a

---

(program
  (repeat_while_statement
    expression_condition: (expression
      postfix_expression: (identifier))))

======
if statement
======

if x {}
if x {} else {}
if x {} else if y {}

---

(program
  (if_statement
    expression_condition: (expression
      postfix_expression: (identifier)))
  (if_statement
    expression_condition: (expression
      postfix_expression: (identifier))
    else_clause: (else_clause))
  (if_statement
    expression_condition: (expression
      postfix_expression: (identifier))
    else_clause: (else_clause
      if_statement: (if_statement
        expression_condition: (expression
          postfix_expression: (identifier))))))

======
guard Statements
======

guard x else {}

---

(program
  (guard_statement
    expression_condition: (expression
      postfix_expression: (identifier))))

======
switch statement
======

switch x {
case _:
case let x:
case var y:
case ():
case .A:
case .A(_, _):
case is Int:
case _ as Int:
default:
}

---

(program
	(switch_statement (identifier)
		(case_statement (wildcard_pattern))
		(case_statement (value_binding_pattern (identifier)))
		(case_statement (value_binding_pattern (identifier)))
		(case_statement (tuple))
		(case_statement (enum_case_pattern (identifier)))
		(case_statement (enum_case_pattern (identifier) (tuple (identifier) (identifier))))
		(case_statement (is_pattern (type (standard_type))))
		(case_statement (as_pattern (wildcard_pattern) (type (standard_type))))
		(case_statement)))

======
labeled statement
======

label: for x in y {}
label: if x {}

---

(program
  (labeled_statement
    (identifier)
    statement: (for_in_statement
      variable: (identifier_pattern
        (identifier))
      collection: (expression
        postfix_expression: (identifier))))
  (labeled_statement
    (identifier)
    statement: (if_statement
      expression_condition: (expression
        postfix_expression: (identifier)))))

======
break statement
======

break
break label

---

(program
  (break_statement)
  (break_statement
    (identifier)))

======
continue statement
======

continue
continue label

---

(program
  (continue_statement)
  (continue_statement
    (identifier)))

======
fallthrough statement
======

fallthrough

---

(program 
  (fallthrough_statement))

======
return statement
======

return
return x

---

(program
  (return_statement)
  (return_statement
    (expression
      postfix_expression: (identifier))))

======
throw statement
======

throw x

---

(program
  (throw_statement
    expression: (expression
      postfix_expression: (identifier))))

======
defer statement
======

defer {}

---

(program
  (defer_statement))

======
do statement
======

do {}
do {} catch {}
do {} catch let e {}

---

(program
  (do_statement)
  (do_statement
    catch_clauses: (catch_clause))
  (do_statement
    catch_clauses: (catch_clause
      (catch_pattern
        (value_binding_pattern
          (identifier_pattern
            (identifier)))))))


======
conditional compilation - `os` variants
======

#if os(iOS) || os(macOS)
#endif
#if os(tvOS)
#endif
#if os(iOS) && os(Linux)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition)
      (compilation_condition)))
  (conditional_compilation_block
    condition: (compilation_condition))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition)
      (compilation_condition))))

======
conditional compilation - `arch` variants
======

#if arch(x86_64)
#endif
#if arch(arm) || arch(arm64)
#endif
#if arch(i386) && arch(x86_64)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition)
      (compilation_condition)))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition)
      (compilation_condition))))

======
conditional compilation - `canImport`
======

#if canImport(UIKit)
#elseif canImport(Foundation)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (module_name))
    alternatives: (elseif_directive_clause
      condition: (compilation_condition
        (module_name)))))

======
conditional compilation - `targetEnvironment`
======

#if targetEnvironment(simulator) || targetEnvironment(macCatalyst)
#endif
#if targetEnvironment(macCatalyst)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition)
      (compilation_condition)))
  (conditional_compilation_block
    condition: (compilation_condition)))

======
conditional compilation - `compiler` version
======

#if compiler(>=5)
#endif
#if compiler(<4)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (number)))
  (conditional_compilation_block
    condition: (compilation_condition
      (number))))

======
conditional compilation - `swift` version
======


#if swift(>=5)
#endif
#if compiler(<4.2)
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (number)))
  (conditional_compilation_block
    condition: (compilation_condition
      (number))))

======
conditional compilation - Booleans and Identifiers
======

#if x
#endif
#if true
#endif
#if (true)
#endif
#if !true
#endif
#if true && true
#endif
#if true || true
#endif
#if true
#elseif false
#elseif x
#else
#endif
#if TREE_SITTER_DEBUG
#endif

---

(program
  (conditional_compilation_block
    condition: (compilation_condition
      (identifier)))
  (conditional_compilation_block
    condition: (compilation_condition
      (boolean_literal)))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition
        (boolean_literal))))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition
        (boolean_literal))))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition
        (boolean_literal))
      (compilation_condition
        (boolean_literal))))
  (conditional_compilation_block
    condition: (compilation_condition
      (compilation_condition
        (boolean_literal))
      (compilation_condition
        (boolean_literal))))
  (conditional_compilation_block
    condition: (compilation_condition
      (boolean_literal))
    alternatives: (elseif_directive_clause
      condition: (compilation_condition
        (boolean_literal)))
    alternatives: (elseif_directive_clause
      condition: (compilation_condition
        (identifier)))
    failure: (else_directive_clause))
  (conditional_compilation_block
    condition: (compilation_condition
      (identifier))))
======
multiple statements on a line
======

x;y;z

---

(program
  (expression
    postfix_expression: (identifier))
  (expression
    postfix_expression: (identifier))
  (expression
    postfix_expression: (identifier)))

======
multiple statements on multiple lines
======

x
y
z

---

(program
  (expression
    postfix_expression: (identifier))
  (expression
    postfix_expression: (identifier))
  (expression
    postfix_expression: (identifier)))
